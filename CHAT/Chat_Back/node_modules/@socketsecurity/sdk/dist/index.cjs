"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketSdk = void 0;
exports.createUserAgentFromPkgJson = createUserAgentFromPkgJson;
const node_events_1 = __importDefault(require("node:events"));
const node_fs_1 = require("node:fs");
const node_https_1 = __importDefault(require("node:https"));
const node_path_1 = __importDefault(require("node:path"));
const node_readline_1 = __importDefault(require("node:readline"));
const abort_signal_1 = __importDefault(require("@socketsecurity/registry/lib/constants/abort-signal"));
// @ts-ignore
const package_json_1 = __importDefault(require("../package.json"));
const defaultUserAgent = createUserAgentFromPkgJson(package_json_1.default);
class ResponseError extends Error {
    response;
    constructor(response, message) {
        super(`${message}: ${response.statusCode} - ${response.statusMessage}`);
        this.response = response;
    }
}
async function createDeleteRequest(baseUrl, urlPath, options) {
    const req = node_https_1.default.request(`${baseUrl}${urlPath}`, {
        method: 'DELETE',
        ...options
    });
    const { 0: res } = (await node_events_1.default.once(req, 'response'));
    if (!isResponseOk(res)) {
        throw new ResponseError(res, 'Delete request failed');
    }
    return res;
}
async function createGetRequest(baseUrl, urlPath, options) {
    const req = node_https_1.default
        .request(`${baseUrl}${urlPath}`, {
        method: 'GET',
        ...options
    })
        .end();
    const { 0: res } = (await node_events_1.default.once(req, 'response'));
    if (!isResponseOk(res)) {
        throw new ResponseError(res, 'Get request failed');
    }
    return res;
}
async function createPostRequest(baseUrl, urlPath, postJson, options) {
    const req = node_https_1.default
        .request(`${baseUrl}${urlPath}`, {
        method: 'POST',
        ...options
    })
        .end(JSON.stringify(postJson));
    const { 0: res } = (await node_events_1.default.once(req, 'response'));
    if (!isResponseOk(res)) {
        throw new ResponseError(res, 'Post request failed');
    }
    return res;
}
function createRequestBodyForFilepaths(filepaths) {
    const requestBody = [];
    for (const p of filepaths) {
        // Multipart header for each file.
        requestBody.push(`Content-Disposition: form-data; name="file"; filename="${node_path_1.default.basename(p)}"\n`, `Content-Type: application/octet-stream\n\n`, (0, node_fs_1.createReadStream)(p), 
        // New line after file content.
        '\n');
    }
    return requestBody;
}
function createRequestBodyForJson(jsonData, basename = 'data.json') {
    const ext = node_path_1.default.extname(basename);
    const name = node_path_1.default.basename(basename, ext);
    return [
        `Content-Disposition: form-data; name="${name}"; filename="${basename}"\n`,
        'Content-Type: application/json\n\n',
        JSON.stringify(jsonData),
        // New line after file content.
        '\n'
    ];
}
async function createUploadRequest(baseUrl, urlPath, requestBodyNoBoundaries, options) {
    // Generate a unique boundary for multipart encoding.
    const boundary = `----NodeMultipartBoundary${Date.now()}`;
    const boundarySep = `--${boundary}\n`;
    // Create request body as a stream.
    const requestBody = [
        ...(requestBodyNoBoundaries.length
            ? requestBodyNoBoundaries.flatMap(e => [boundarySep, e])
            : [boundarySep]),
        `--${boundary}--\n`
    ];
    const req = node_https_1.default.request(`${baseUrl}${urlPath}`, {
        method: 'POST',
        ...options,
        headers: {
            ...options?.headers,
            'Content-Type': `multipart/form-data; boundary=${boundary}`
        }
    });
    // Send the request body (headers + files).
    for (const part of requestBody) {
        if (typeof part === 'string') {
            req.write(part);
        }
        else {
            part.pipe(req, { end: false });
            // Wait for file streaming to complete.
            // eslint-disable-next-line no-await-in-loop
            await node_events_1.default.once(part, 'end');
            // Ensure a new line after file content.
            req.write('\n');
        }
    }
    // Close request after writing all data.
    req.end();
    const { 0: res } = (await node_events_1.default.once(req, 'response'));
    if (!isResponseOk(res)) {
        throw new ResponseError(res, 'Upload failed');
    }
    return res;
}
async function getResponseJson(response) {
    let data = '';
    for await (const chunk of response) {
        data += chunk;
    }
    try {
        return JSON.parse(data);
    }
    catch {
        throw new Error(`Invalid JSON response: ${data}`);
    }
}
function isResponseOk(response) {
    const { statusCode } = response;
    return (typeof statusCode === 'number' && statusCode >= 200 && statusCode <= 299);
}
/**
 * Package.json data to base the User-Agent on
 */
function createUserAgentFromPkgJson(pkgData) {
    const { homepage } = pkgData;
    const name = pkgData.name.replace('@', '').replace('/', '-');
    return `${name}/${pkgData.version}${homepage ? ` (${homepage})` : ''}`;
}
// https://github.com/sindresorhus/got/blob/v14.4.6/documentation/2-options.md#agent
const agentNames = new Set(['http', 'https', 'http2']);
class SocketSdk {
    #baseUrl;
    #reqOptions;
    /**
     * @throws {SocketSdkAuthError}
     */
    constructor(apiToken, options) {
        const { agent: agentOrObj, baseUrl = 'https://api.socket.dev/v0/', userAgent } = { __proto__: null, ...options };
        const agentKeys = agentOrObj ? Object.keys(agentOrObj) : [];
        const agent = (agentKeys.length && agentKeys.every(k => agentNames.has(k))
            ? agentOrObj.https
            : agentOrObj);
        this.#baseUrl = baseUrl;
        this.#reqOptions = {
            ...(agent ? { agent } : {}),
            headers: {
                Authorization: `Basic ${btoa(`${apiToken}:`)}`,
                'User-Agent': `${userAgent ? `${userAgent} ` : ''}${defaultUserAgent}`
            },
            signal: abort_signal_1.default
        };
    }
    async #createBatchPurlRequest(queryParams, componentsObj) {
        // Adds the first 'abort' listener to abortSignal.
        const req = node_https_1.default
            .request(`${this.#baseUrl}purl?${new URLSearchParams(queryParams ?? '')}`, {
            method: 'POST',
            ...this.#reqOptions
        })
            .end(JSON.stringify(componentsObj));
        // Adds the second 'abort' listener to abortSignal.
        const { 0: res } = (await node_events_1.default.once(req, 'response', {
            signal: abort_signal_1.default
        }));
        if (!isResponseOk(res)) {
            throw new ResponseError(res, 'Batch purl request failed');
        }
        return res;
    }
    async *#createBatchPurlGenerator(queryParams, componentsObj) {
        let res;
        try {
            res = await this.#createBatchPurlRequest(queryParams, componentsObj);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
        const rli = node_readline_1.default.createInterface({
            input: res,
            crlfDelay: Infinity,
            signal: abort_signal_1.default
        });
        for await (const line of rli) {
            yield this.#handleApiSuccess(JSON.parse(line));
        }
    }
    #handleApiError(error) {
        if (!(error instanceof ResponseError)) {
            throw new Error('Unexpected error when calling API', {
                cause: error
            });
        }
        const statusCode = error.response.statusCode;
        if (statusCode >= 500) {
            throw new Error('API returned an error', { cause: error });
        }
        return {
            success: false,
            status: statusCode,
            error: error.message ?? ''
        };
    }
    #handleApiSuccess(data) {
        return {
            success: true,
            status: 200,
            data: data
        };
    }
    async batchPackageFetch(queryParams, componentsObj) {
        let res;
        try {
            res = await this.#createBatchPurlRequest(queryParams, componentsObj);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
        // Parse the newline delimited JSON response.
        const rl = node_readline_1.default.createInterface({
            input: res,
            crlfDelay: Infinity
        });
        const results = [];
        for await (const line of rl) {
            if (line.trim()) {
                results.push(JSON.parse(line));
            }
        }
        return this.#handleApiSuccess(results);
    }
    async *batchPackageStream(queryParams, componentsObj, concurrencyLimit = 50) {
        // The createBatchPurlGenerator method will add 2 'abort' event listeners to
        // abortSignal so we multiply the concurrencyLimit by 2.
        const neededMaxListeners = concurrencyLimit * 2;
        // Increase abortSignal max listeners count to avoid Node's MaxListenersExceededWarning.
        const oldAbortSignalMaxListeners = node_events_1.default.getMaxListeners(abort_signal_1.default);
        let abortSignalMaxListeners = oldAbortSignalMaxListeners;
        if (oldAbortSignalMaxListeners < neededMaxListeners) {
            abortSignalMaxListeners = oldAbortSignalMaxListeners + neededMaxListeners;
            node_events_1.default.setMaxListeners(abortSignalMaxListeners, abort_signal_1.default);
        }
        const { components } = componentsObj;
        const { length: componentsCount } = components;
        const running = [];
        let index = 0;
        const enqueueGen = () => {
            if (index >= componentsCount) {
                // No more work to do.
                return;
            }
            const generator = this.#createBatchPurlGenerator(queryParams, {
                // Chunk components.
                components: components.slice(index, index + 25)
            });
            continueGen(generator);
            index += 25;
        };
        const continueGen = (generator) => {
            let resolveFn;
            running.push({
                generator,
                promise: new Promise(resolve => (resolveFn = resolve))
            });
            void generator
                .next()
                .then(iteratorResult => resolveFn({ generator, iteratorResult }));
        };
        // Start initial batch of generators.
        while (running.length < concurrencyLimit && index < componentsCount) {
            enqueueGen();
        }
        while (running.length > 0) {
            // eslint-disable-next-line no-await-in-loop
            const { generator, iteratorResult } = await Promise.race(running.map(entry => entry.promise));
            // Remove generator.
            running.splice(running.findIndex(entry => entry.generator === generator), 1);
            if (iteratorResult.done) {
                // Start a new generator if available.
                enqueueGen();
            }
            else {
                yield iteratorResult.value;
                // Keep fetching values from this generator.
                continueGen(generator);
            }
        }
        // Reset abortSignal max listeners count.
        if (abortSignalMaxListeners > oldAbortSignalMaxListeners) {
            node_events_1.default.setMaxListeners(oldAbortSignalMaxListeners, abort_signal_1.default);
        }
    }
    async createDependenciesSnapshot(params, filepaths, pathsRelativeTo = '.') {
        const basePath = node_path_1.default.join(process.cwd(), pathsRelativeTo);
        const absFilepaths = filepaths.map(p => node_path_1.default.join(basePath, p));
        try {
            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `dependencies/upload?${new URLSearchParams(params)}`, createRequestBodyForFilepaths(absFilepaths), this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createOrgFullScan(orgSlug, queryParams, filepaths, pathsRelativeTo = '.') {
        const basePath = node_path_1.default.join(process.cwd(), pathsRelativeTo);
        const absFilepaths = filepaths.map(p => node_path_1.default.join(basePath, p));
        try {
            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, createRequestBodyForFilepaths(absFilepaths), this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createOrgRepo(orgSlug, params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos`, { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createReportFromFilepaths(filepaths, pathsRelativeTo = '.', issueRules) {
        const basePath = node_path_1.default.join(process.cwd(), pathsRelativeTo);
        const absFilepaths = filepaths.map(p => node_path_1.default.join(basePath, p));
        try {
            const data = await createUploadRequest(this.#baseUrl, 'report/upload', [
                ...createRequestBodyForFilepaths(absFilepaths),
                ...(issueRules
                    ? createRequestBodyForJson(issueRules, 'issueRules.json')
                    : [])
            ], {
                ...this.#reqOptions,
                method: 'PUT'
            });
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    // Alias to preserve backwards compatibility.
    async createReportFromFilePaths(filepaths, pathsRelativeTo = '.', issueRules) {
        return await this.createReportFromFilepaths(filepaths, pathsRelativeTo, issueRules);
    }
    async deleteOrgFullScan(orgSlug, fullScanId) {
        try {
            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async deleteOrgRepo(orgSlug, repoSlug) {
        try {
            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getAuditLogEvents(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/audit-log?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getIssuesByNPMPackage(pkgName, version) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/issues`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgAnalytics(time) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/org/${encodeURIComponent(time)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrganizations() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'organizations', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScan(orgSlug, fullScanId, file) {
        try {
            const req = node_https_1.default.request(`${this.#baseUrl}orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`, {
                method: 'GET',
                ...this.#reqOptions
            });
            const { 0: res } = await node_events_1.default.once(req, 'response');
            if (!isResponseOk(res)) {
                throw new ResponseError(res, 'Get request failed');
            }
            if (file) {
                res.pipe((0, node_fs_1.createWriteStream)(file));
            }
            else {
                res.pipe(process.stdout);
            }
            return this.#handleApiSuccess(res);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScanList(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScanMetadata(orgSlug, fullScanId) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}/metadata`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgLicensePolicy(orgSlug) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/license-policy`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgRepo(orgSlug, repoSlug) {
        const orgSlugParam = encodeURIComponent(orgSlug);
        const repoSlugParam = encodeURIComponent(repoSlug);
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${orgSlugParam}/repos/${repoSlugParam}`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgRepoList(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos?${new URLSearchParams(queryParams ?? '')}`));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgSecurityPolicy(orgSlug) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/security-policy`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getQuota() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'quota', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getRepoAnalytics(repo, time) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/repo/${encodeURIComponent(repo)}/${encodeURIComponent(time)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReport(id) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `report/view/${encodeURIComponent(id)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReportList() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/list', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReportSupportedFiles() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/supported', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getScoreByNPMPackage(pkgName, version) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/score`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async postSettings(selectors) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'settings', { json: selectors }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async searchDependencies(params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'dependencies/search', { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async updateOrgRepo(orgSlug, repoSlug, params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`, { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
}
exports.SocketSdk = SocketSdk;
//# sourceMappingURL=index.js.map